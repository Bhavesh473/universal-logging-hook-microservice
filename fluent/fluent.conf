<source>
  @type http
  port 9880
  bind 0.0.0.0
</source>

<source>
  @type forward
  port 24224
  bind 0.0.0.0
</source>

# Single combined filter:
#  - sets level/source/timestamp/received_at
#  - redacts passwords/tokens from message and request body
#  - redacts Authorization header
<filter **>
  @type record_transformer
  enable_ruby true
  <record>
    level ${record["level"] || "INFO"}
    source ${record["source"] || "unknown"}
    timestamp ${record["timestamp"] || Time.now.utc.iso8601}
    received_at ${Time.now.utc.iso8601}

    # normalized & redacted message (works if message is JSON string or plain text)
    message ${ begin
      m = (record["message"] || record["msg"] || "").to_s
      require 'json'
      begin
        # try parse JSON payload inside message
        json_obj = JSON.parse(m) rescue nil
        if json_obj.is_a?(Hash)
          ["password","pass","pwd","id_token","access_token","token","code"].each { |k|
            json_obj[k] = "[REDACTED_PASSWORD]" if json_obj.key?(k)
          }
          m = json_obj.to_json
        else
          # fallback regex redaction for urlencoded/form/plain text
          m = m.gsub(/("?(?:password|pass|pwd|id_token|access_token|token|code)"?\s*[:=]\s*)"[^"&\s]*/i, '\1"[REDACTED_PASSWORD]"')
          m = m.gsub(/(password|pass|pwd)=[^&\s]*/i, 'password=[REDACTED_PASSWORD]')
        end
      rescue => e
        m = m.gsub(/("?(?:password|pass|pwd)"?\s*[:=]\s*)"[^"&\s]*/i, '\1"[REDACTED_PASSWORD]"').gsub(/(password|pass|pwd)=[^&\s]*/i,'password=[REDACTED_PASSWORD]')
      end
      m
    end }

    # redacted request body if present in record["request_body"] or record["body"] or record["request"]
    request_body ${ begin
      b = record["request_body"] || record["body"] || record["request"] || ""
      require 'json'
      begin
        parsed = b.is_a?(String) ? (JSON.parse(b) rescue nil) : b
        if parsed.is_a?(Hash)
          ["password","pass","pwd","id_token","access_token","token","code"].each { |k|
            parsed[k] = "[REDACTED_PASSWORD]" if parsed.key?(k)
          }
          rb = parsed.to_json
        else
          rb = b.to_s.gsub(/("?(?:password|pass|pwd|id_token|access_token|token|code)"?\s*[:=]\s*)"[^"&\s]*/i, '\1"[REDACTED_PASSWORD]"')
          rb = rb.gsub(/(password|pass|pwd)=[^&\s]*/i, 'password=[REDACTED_PASSWORD]')
        end
      rescue => e
        rb = b.to_s.gsub(/("?(?:password|pass|pwd)"?\s*[:=]\s*)"[^"&\s]*/i, '\1"[REDACTED_PASSWORD]"').gsub(/(password|pass|pwd)=[^&\s]*/i,'password=[REDACTED_PASSWORD]')
      end
      rb
    end }

    # redact Authorization header (if headers present)
    headers ${ begin
      h = record["headers"] || record["http_headers"] || {}
      if h.is_a?(Hash)
        if h.key?("Authorization")
          h["Authorization"] = "[REDACTED_AUTH]"
        end
        if h.key?("authorization")
          h["authorization"] = "[REDACTED_AUTH]"
        end
      end
      h
    end }
  </record>
</filter>

# Fix for Fluentd's own logs (avoid duplicate/deprecation warnings)
<label @FLUENT_LOG>
  <match **>
    @type stdout
  </match>
</label>

# Output to stdout so Docker captures it (dashboard tails docker logs)
<match **>
  @type stdout
</match>
